// Generated by CoffeeScript 1.6.1
(function() {
  var LatLon, NGrams, RedisTweetCounts, Stream, TweetCountsFactory, TweetTokenizer, app, express, geohash, port, stream, tweetCounts, twit, twitter, util, _,
    _this = this;

  express = require("express");

  app = express();

  app.use(express.logger());

  util = require('util');

  twitter = require('twitter');

  geohash = require('ngeohash');

  _ = require('underscore');

  NGrams = require("natural").NGrams;

  twit = new twitter({
    consumer_key: 'mCp0qZ0zGGcvA9ZKVo7xQ',
    consumer_secret: 'X1Z4FaK8Hv68ZoTUCmiRjDy6IP5d5n7OHYwC6es4A',
    access_token_key: '11510772-MZIWUADlvY7A9Cbz6kKpqbuRM7EfWrdskAnXNpxpE',
    access_token_secret: process.env['TWITTER_ACCESS_TOKEN_SECRET']
  });

  LatLon = (function() {

    function LatLon(lat, lon) {
      this.latitude = lat;
      this.longitude = lon;
    }

    LatLon.prototype.toId = function() {
      return "" + this.latitude + "," + this.longitude;
    };

    LatLon.prototype.toGeoHash = function(precision) {
      return geohash.encode(this.latitude, this.longitude, precision);
    };

    LatLon.fromId = function(id) {
      var latS, lonS, _ref;
      _ref = id.split(","), latS = _ref[0], lonS = _ref[1];
      return new LatLon(parseFloat(latS), parseFloat(lonS));
    };

    LatLon.fromGeoHash = function(geoHash) {
      var decoded;
      decoded = geohash.decode(geoHash);
      return new LatLon(decoded.latitude, decoded.longitude);
    };

    return LatLon;

  })();

  RedisTweetCounts = (function() {

    function RedisTweetCounts(redis, precision) {
      var _this = this;
      this.redis = redis;
      this.precision = precision != null ? precision : 6;
      this.latLonFullId = function(latLon) {
        return RedisTweetCounts.prototype.latLonFullId.apply(_this, arguments);
      };
      this.version = "v3";
      this.prefix = "" + this.version + ".geohash:" + this.precision + ":";
    }

    RedisTweetCounts.prototype.add = function(latLon, text) {
      var id, nGram, _i, _len, _ref, _results;
      this.redis.incr("" + this.version + "." + this.precision + ":count");
      id = this.latLonFullId(latLon);
      this.redis.zincrby("" + this.version + ".geohashes:" + this.precision, 1, id);
      _ref = text.nGrams;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        nGram = _ref[_i];
        _results.push(this.redis.hincrby(id, "ng:" + text.length + ":" + nGram, 1));
      }
      return _results;
    };

    RedisTweetCounts.prototype.latLonFullId = function(latLon) {
      return "" + this.prefix + (latLon.toGeoHash(this.precision));
    };

    RedisTweetCounts.prototype.dump = function(callback) {
      var _this = this;
      return this.redis.get("" + this.version + "." + this.precision + ":count", function(err, totalBuffer) {
        var total;
        if (err != null) {
          console.log(err);
          return callback({
            'total': 0,
            'counts': 0
          });
        } else {
          total = parseInt(totalBuffer.toString());
          return _this.redis.zrange(["" + _this.version + ".geohashes:" + _this.precision, 0, -1, 'withscores'], function(err, response) {
            var count, counts, entry, fullId, geoHash, keyIndex, _i, _ref;
            counts = [];
            for (keyIndex = _i = 0, _ref = response.length; _i < _ref; keyIndex = _i += 2) {
              fullId = response[keyIndex];
              geoHash = fullId.toString().substring(_this.prefix.length);
              count = parseInt(response[keyIndex + 1].toString());
              entry = {
                lat_lon: LatLon.fromGeoHash(geoHash),
                count: count
              };
              counts.push(entry);
            }
            return callback({
              'total': total,
              'counts': counts
            });
          });
        }
      });
    };

    return RedisTweetCounts;

  })();

  TweetCountsFactory = (function() {

    function TweetCountsFactory() {}

    TweetCountsFactory.create = function() {
      var client, redis, redisURL, url;
      redis = require('redis');
      if (process.env.REDISCLOUD_URL != null) {
        console.log("Using RedisCloud Redis");
        url = require('url');
        redisURL = url.parse(process.env.REDISCLOUD_URL);
        client = redis.createClient(redisURL.port, redisURL.hostname, {
          no_ready_check: true
        });
        client.auth(redisURL.auth.split(":")[1]);
      } else {
        console.log("Using Local Redis");
        client = redis.createClient();
      }
      return new RedisTweetCounts(client);
    };

    return TweetCountsFactory;

  })();

  TweetTokenizer = (function() {

    function TweetTokenizer(length) {
      var _this = this;
      this.length = length;
      this.nGrams = function(text) {
        return TweetTokenizer.prototype.nGrams.apply(_this, arguments);
      };
    }

    TweetTokenizer.prototype.nGrams = function(text) {
      var nGrams, nGramsForEachWord, word, words;
      words = ("^" + text + "$").toLowerCase().split(/\s+/);
      nGramsForEachWord = _.flatten((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = words.length; _i < _len; _i++) {
          word = words[_i];
          _results.push(NGrams.ngrams(word.split(""), this.length));
        }
        return _results;
      }).call(this), true);
      nGrams = _.uniq(_.map(nGramsForEachWord, function(d) {
        return d.join("");
      }));
      return {
        'length': this.length,
        'nGrams': nGrams
      };
    };

    return TweetTokenizer;

  })();

  Stream = (function() {

    function Stream(tweetCounts, twitter, tokenizer, restartAfterSeconds) {
      var _this = this;
      this.tweetCounts = tweetCounts;
      this.twitter = twitter;
      this.tokenizer = tokenizer;
      if (restartAfterSeconds == null) {
        restartAfterSeconds = 30 * 60;
      }
      this.handleData = function(data) {
        return Stream.prototype.handleData.apply(_this, arguments);
      };
      this.restart = function() {
        return Stream.prototype.restart.apply(_this, arguments);
      };
      this.restartAfterMillis = restartAfterSeconds * 1000;
    }

    Stream.prototype.start = function() {
      var _this = this;
      return this.twitter.stream('statuses/sample', function(stream) {
        _this.stream = stream;
        console.log("Started listening for tweets, will restart after " + _this.restartAfterMillis + " millis");
        stream.on('data', _this.handleData);
        return setTimeout(_this.restart, _this.restartAfterMillis);
      });
    };

    Stream.prototype.restart = function() {
      if (this.stream != null) {
        console.log("Destroying stream");
        this.stream.destroy();
      }
      return this.start();
    };

    Stream.prototype.handleData = function(data) {
      if ((data.geo != null) && (data.geo.coordinates != null)) {
        return this.tweetCounts.add(new LatLon(data.geo.coordinates[0], data.geo.coordinates[1]), this.tokenizer.nGrams(data.text));
      }
    };

    return Stream;

  })();

  tweetCounts = TweetCountsFactory.create();

  stream = new Stream(tweetCounts, twit, new TweetTokenizer(2));

  stream.start();

  app.all('*', function(req, resp, next) {
    resp.header("Access-Control-Allow-Origin", "*");
    resp.header("Access-Control-Allow-Headers", "X-Requested-With");
    return next();
  });

  app.get('/', function(req, resp) {
    return resp.send('Hello World!');
  });

  app.get('/counts.json', function(req, resp) {
    return tweetCounts.dump(function(dumped) {
      return resp.send(dumped);
    });
  });

  app.get('/counts/grouped-by-geohash/precision-:precision.json', function(req, resp) {
    return tweetCounts.dump(function(dumped) {
      var byGeoHash, counts;
      byGeoHash = _.countBy(dumped.counts, function(entry) {
        return geohash.encode(entry.lat_lon.latitude, entry.lat_lon.longitude, req.params.precision);
      });
      counts = _.map(byGeoHash, function(count, encoded) {
        return {
          'lat_lon': geohash.decode(encoded),
          'count': count
        };
      });
      return resp.send({
        'total': dumped.total,
        'counts': counts
      });
    });
  });

  port = process.env.PORT || 5000;

  app.listen(port, function() {
    return console.log("Listening on " + port);
  });

}).call(this);
